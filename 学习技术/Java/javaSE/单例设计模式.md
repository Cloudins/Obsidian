

## 饿汉式

1. 构造器私有化 =》  防止直接new
2. 类的内部创建对象
3. 向外暴露一个静态的公共方法 

```java
public static void main(String[] args) {
	//通过方法可以获取对象
	GirlFriend instance = GirlFriend.getInstance();
	System.out.println(instance);
	GirlFriend instance2 = GirlFriend.getInstance();
	System.out.println(instance2);
	System.out.println(instance == instance2);//T
	//System.out.println(GirlFriend.n1);

	/**
	缺点：
	可能会造成创建了对象，却没有使用
	*/
}
class GirlFriend {
	private String name;
	//public static int n1 = 100;
	//为了能够在静态方法中，返回gf 对象，需要将其修饰为static
	//對象，通常是重量級的對象, 餓漢式可能造成創建了對象，但是沒有使用.
	private static GirlFriend gf = new GirlFriend("小红红");
	//如何保障我们只能创建一个GirlFriend 对象
	//步骤[单例模式-饿汉式]
	//1. 将构造器私有化
	//2. 在类的内部直接创建对象(该对象是static)
	//3. 提供一个公共的static 方法，返回gf 对象
	private GirlFriend(String name) {
	System.out.println("構造器被調用.");
	this.name = name;
	}
	public static GirlFriend getInstance() {
	return gf;
}
@Override
public String toString() {
		return "GirlFriend{" +
		"name='" + name + '\'' +
		'}';
}
```



## 懒汉式

 1. 构造器私有化 =》  防止直接new
2. 类的内部创建对象
3. 提供一个公共的静态方法，返回一个对象 

```java
public static void main(String[] args) {
	//通过方法可以获取对象
	GirlFriend instance = GirlFriend.getInstance();
	System.out.println(instance);
	GirlFriend instance2 = GirlFriend.getInstance();
	System.out.println(instance2);
	System.out.println(instance == instance2);//T
	//System.out.println(GirlFriend.n1);

	/**
	缺点：
	可能会造成创建了对象，却没有使用
	*/
}
class GirlFriend {
	private String name;
	//public static int n1 = 100;
	//为了能够在静态方法中，返回gf 对象，需要将其修饰为static
	//對象，通常是重量級的對象, 餓漢式可能造成創建了對象，但是沒有使用.
	private static GirlFriend gf;
	//如何保障我们只能创建一个GirlFriend 对象
	//步骤[单例模式-饿汉式]
	//1. 将构造器私有化
	//2. 在类的内部直接创建对象(该对象是static)
	//3. 提供一个公共的static 方法，返回gf 对象
	private GirlFriend(String name) {
		System.out.println("構造器被調用.");
		this.name = name;
	}
	public static GirlFriend getInstance() {
		if(gf == null){
			gf = new GirlFriend();
		}
		return gf;
	}
@Override
public String toString() {
		return "GirlFriend{" +
		"name='" + name + '\'' +
		'}';
}
```



![[Pasted image 20230314193547.png]]
